/**
 * Amplication Data Provider for Refine
 * 
 * This data provider connects to NestJS backends generated by Amplication.
 * It follows the REST API conventions generated by Amplication.
 */

import {
   DataProvider,
   BaseRecord,
   GetListParams,
   GetListResponse,
   GetOneParams,
   GetOneResponse,
   CreateParams,
   CreateResponse,
   UpdateParams,
   UpdateResponse,
   DeleteOneParams,
   DeleteOneResponse,
   GetManyParams,
   GetManyResponse,
} from "@refinedev/core";

interface AmplicationDataProviderConfig {
   apiUrl: string;
   token?: string;
}

/**
 * Creates a Refine Data Provider for Amplication-generated REST APIs.
 * 
 * API Conventions (Amplication generates):
 * - GET /api/{entity} — list with pagination, filtering, sorting
 * - GET /api/{entity}/{id} — get one
 * - POST /api/{entity} — create
 * - PUT /api/{entity}/{id} — update (full)
 * - PATCH /api/{entity}/{id} — update (partial)
 * - DELETE /api/{entity}/{id} — delete
 */
export const createAmplicationDataProvider = (
   config: AmplicationDataProviderConfig
): DataProvider => {
   const { apiUrl, token } = config;

   const getHeaders = (): HeadersInit => {
      const headers: HeadersInit = {
         "Content-Type": "application/json",
      };
      if (token) {
         headers["Authorization"] = `Bearer ${token}`;
      }
      return headers;
   };

   const handleResponse = async <T>(response: Response): Promise<T> => {
      if (!response.ok) {
         const error = await response.json().catch(() => ({}));
         throw new Error(error.message || `HTTP Error: ${response.status}`);
      }
      return response.json();
   };

   return {
      /**
       * Get a list of records with pagination, sorting, and filtering.
       */
      getList: async <TData extends BaseRecord = BaseRecord>({
         resource,
         pagination,
         sorters,
         filters,
      }: GetListParams): Promise<GetListResponse<TData>> => {
         const { current = 1, pageSize = 10 } = pagination ?? {};
         
         // Build query params
         const params = new URLSearchParams();
         
         // Pagination (Amplication uses _start and _end)
         const start = (current - 1) * pageSize;
         const end = start + pageSize;
         params.append("_start", String(start));
         params.append("_end", String(end));
         
         // Sorting
         if (sorters && sorters.length > 0) {
            const { field, order } = sorters[0];
            params.append("_sort", field);
            params.append("_order", order.toUpperCase());
         }
         
         // Filtering
         if (filters) {
            filters.forEach((filter) => {
               if ("field" in filter && filter.value !== undefined) {
                  // Simple equality filter
                  params.append(filter.field, String(filter.value));
               }
            });
         }

         const url = `${apiUrl}/${resource}?${params.toString()}`;
         
         const response = await fetch(url, {
            method: "GET",
            headers: getHeaders(),
         });

         const result = await handleResponse<{ data: TData[]; total: number }>(response);
         
         return {
            data: result.data,
            total: result.total,
         };
      },

      /**
       * Get a single record by ID.
       */
      getOne: async <TData extends BaseRecord = BaseRecord>({
         resource,
         id,
      }: GetOneParams): Promise<GetOneResponse<TData>> => {
         const url = `${apiUrl}/${resource}/${id}`;
         
         const response = await fetch(url, {
            method: "GET",
            headers: getHeaders(),
         });

         const data = await handleResponse<TData>(response);
         
         return { data };
      },

      /**
       * Create a new record.
       */
      create: async <TData extends BaseRecord = BaseRecord, TVariables = {}>({
         resource,
         variables,
      }: CreateParams<TVariables>): Promise<CreateResponse<TData>> => {
         const url = `${apiUrl}/${resource}`;
         
         const response = await fetch(url, {
            method: "POST",
            headers: getHeaders(),
            body: JSON.stringify(variables),
         });

         const data = await handleResponse<TData>(response);
         
         return { data };
      },

      /**
       * Update an existing record.
       */
      update: async <TData extends BaseRecord = BaseRecord, TVariables = {}>({
         resource,
         id,
         variables,
      }: UpdateParams<TVariables>): Promise<UpdateResponse<TData>> => {
         const url = `${apiUrl}/${resource}/${id}`;
         
         const response = await fetch(url, {
            method: "PUT",
            headers: getHeaders(),
            body: JSON.stringify(variables),
         });

         const data = await handleResponse<TData>(response);
         
         return { data };
      },

      /**
       * Delete a record.
       */
      deleteOne: async <TData extends BaseRecord = BaseRecord, TVariables = {}>({
         resource,
         id,
      }: DeleteOneParams<TVariables>): Promise<DeleteOneResponse<TData>> => {
         const url = `${apiUrl}/${resource}/${id}`;
         
         const response = await fetch(url, {
            method: "DELETE",
            headers: getHeaders(),
         });

         const data = await handleResponse<TData>(response);
         
         return { data };
      },

      /**
       * Get multiple records by IDs.
       */
      getMany: async <TData extends BaseRecord = BaseRecord>({
         resource,
         ids,
      }: GetManyParams): Promise<GetManyResponse<TData>> => {
         // Fetch each record individually (Amplication doesn't have bulk get by default)
         const promises = ids.map((id) =>
            fetch(`${apiUrl}/${resource}/${id}`, {
               method: "GET",
               headers: getHeaders(),
            }).then((res) => handleResponse<TData>(res))
         );

         const data = await Promise.all(promises);
         
         return { data };
      },

      /**
       * Get API URL (required by Refine)
       */
      getApiUrl: () => apiUrl,
   };
};

/**
 * Helper to create entity name from resource.
 * Converts camelCase/PascalCase to lowercase for API endpoints.
 */
export const toApiResource = (entityName: string): string => {
   return entityName.toLowerCase();
};

/**
 * Default export for convenience
 */
export default createAmplicationDataProvider;

